## Objectives
* Learn how to use system calls
* Learn how to create child processes
* Learn how to catch signals
* Learn basic I/O redirection

For this assignment I wrote a simple program that will act as a shell. The program shall:

* Display a command prompt and read in a command line from the user.  Uses "361> " as the prompt.
* Parse the command line into arguments, creating an array of character pointers, where array[0] points to the actual command and rest of the array elements point to the arguments to the command (Similar to main()â€™s argv[])
* Fork off a child and have the child load the requested program by passing the argument vector created in step 2 to exec() family of system calls. The parent should report the PID of the child before proceeding to the next step.  I use the format "PID: 5", where the child's PID is 5.
* Wait for the child to complete executing and report that it ended and its exit value if available, by printing "Exit: 0" (assuming its exit value is 0).
* Repeat for first step forever till user enters the command exit
* shell also supports basic I/O redirection like the unix shell.
	* command > filename Redirects the output of command to filename. The existing contents of filename are overwritten.
	* command >> filenameRedirects the output of command to filename. The output from command is appended to contents of filename. Existing contents are not overwritten.
	* command < filename Command reads its input from filename instead of from stdin.
* shell handles the following signals:
	* SIGINT - Generated by Ctrl-C. This signal allows a user to teminate a running program. Shell should not exit when user presses Ctrl-C but simply report that SIGINT signal has been received by the shell by printing "SIGINT handled".
	* SIGTSTP - Generated by Ctrl-Z. Shell should not exit when user presses Ctrl-Z but simply report that SIGTSTP signal has been received by the shell by printing "SIGTSTP handled".
* The shell need not support background processes or running more than one child at a time.