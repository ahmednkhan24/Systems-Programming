#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include<sys/wait.h>
#include <signal.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>


//---------------------------------------------------------------------------------
// SIGINT - Generated by Ctrl-C. This signal allows a user to teminate a running program. 
// Your shell should not exit when user presses Ctrl-C but simply report that 
// SIGINT signal has been received by the shell by printing "SIGINT handled".
void sigint_handler(int sig)
{
	char msg[] = "SIGINT handled\ncs361>";
	write(1, msg, sizeof(msg));
	return;
}
//---------------------------------------------------------------------------------
// SIGTSTP - Generated by Ctrl-Z. Your shell should not exit when user presses 
// Ctrl-Z but simply report that SIGTSTP signal has been received 
// by the shell by printing "SIGTSTP handled".
void sigtstp_handler(int sig)
{
	char msg[] = "SIGTSTP handled\ncs361>";
	write(1, msg, sizeof(msg));
	return;
}
//---------------------------------------------------------------------------------
// check for the exit command
// returns 1 if the word is exit, 0 otherwise
int checkExit(char *word)
{
	if (strncmp("exit", word, 4) == 0)
		return 1;
	else
		return 0;

}
//---------------------------------------------------------------------------------
// returns 1 if a redirect command and a filename was given
int checkSignFile(char *sign, char *filename)
{
	if (sign[0] != 'z' && filename[0] != '1')
		return 1;
	else
		return 0;
}
//---------------------------------------------------------------------------------
// parses the word and stores the sign into the sign and filename in the arrays
void parseSignFilename(char *word, char *sign, char *filename)
{
	// copy the sign
	strcpy(sign, word);

	//get next word
	word = strtok(NULL, " ");

	// get rid of the newline character
	strtok(word, "\n");

	// copy the filename
	strcpy(filename, word);
}
//---------------------------------------------------------------------------------
// Parse the command line into arguments, creating an array of character pointers, 
// where array[0] points to the actual command and rest of the array elements 
// point to the arguments to the command (Similar to main()â€™s argv[])
int parse(char *line, char **args, char *sign, char *filename)
{
	//break the string up into words
	char *word = strtok(line, " ");

	// check for the exit command
	if (checkExit(word))
	{
		exit(0);
	}

	int i = 0;

	while (word)
	{
		if (strcmp(word, ">") == 0)
		{
			parseSignFilename(word, sign, filename);

			// get next word
			word = strtok(NULL, " ");
		}
		else if (strcmp(word, ">>") == 0)
		{
			parseSignFilename(word, sign, filename);

			// get next word
			word = strtok(NULL, " ");
		}
		else if (strcmp(word, "<") == 0)
		{
			parseSignFilename(word, sign, filename);

			// get next word
			word = strtok(NULL, " ");
		}
		else
		{
			// create memory for this index 
			args[i] = (char*)malloc(sizeof(char) * 100);

			// copy a word to the arg array
			strcpy(args[i], word);


			// get next word
			word = strtok(NULL, " ");

			i++;
		}
	}

	strtok(args[i-1], "\n");
	args[i] = (char*)malloc(sizeof(char) * 100);
	args[i] = (char *)0;

	i++;

	return i;
}
//---------------------------------------------------------------------------------
//print out our array
void print(char **args, int i)
{
	int j; 
	for (j = 0; j < i; j++)
	{
		printf("args[%d]: %s\n", j, args[j]);
	}
}
//---------------------------------------------------------------------------------
// free the memory in both strings
void freeStrings(char *line, char **args, int numArgs, char *sign, char *filename)
{
	free(line);
	free(sign);
	free(filename);

	int i;
	for (i = 0; i < numArgs; i++)
	{
		free(args[i]);
	}

	free(args);
}
//---------------------------------------------------------------------------------
// Fork off a child and have the child load the requested program by passing 
// the argument vector created in step 2 to exec() family of system calls.
void performFork(char **args, char *sign, char *filename)
{
	int pid = fork();

	if (pid == 0) 
	{
		// CHILD 


		if (checkSignFile(sign, filename))
		{
			if (strcmp(sign, ">") == 0)
			{
				int fd = open(filename, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
				dup2(fd, 1);
				close(fd);
			}
			else if (strcmp(sign, ">>") == 0)
			{
				int fd = open(filename, O_APPEND|O_CREAT|O_RDWR, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
				dup2(fd, 1);
				close(fd);
			}
			else if (strcmp(sign, "<") == 0)
			{
				int fd = open(filename, O_RDONLY);
				dup2(fd, 0);
				close(fd);

			}
		}

		//printf("Child with pid %d, about to exec ls\n", getpid());
		execvp(args[0], args);
		exit(0);
	} 
	else 
	{
		// PARENT

		// The parent should report the PID of the child before proceeding to the next step. 
		// You should use the format "PID: 5", where the child's PID is 5.
		printf("PID: %d\n", pid);

		// Wait for the child to complete executing and report that it ended and its 
		// exit value if available, by printing 
		// "Exit: 0" (assuming its exit value is 0).
		int status;
		wait(&status);
		printf("Exit: %d\n",  WEXITSTATUS(status));
	}
}
//---------------------------------------------------------------------------------
int main()
{
	// declare strings
	char *line;
	char **args;
	int numArgs;

	char *sign;
	char *filename;

	signal(SIGINT, sigint_handler);
	signal(SIGTSTP, sigtstp_handler);


	// Repeat forever until user enters the 'exit' command
	while(1)
	{
		// create some space for our strings
		line = (char*)malloc(sizeof(char) * 500);
		args = (char**)malloc(sizeof(char*) * 20);

		sign = (char*)malloc(sizeof(char) * 100);
		filename = (char*)malloc(sizeof(char) * 100);

		sign[0] = 'z';
		filename[0] ='1';


		// Display a command prompt and read in a command line from the user.  
		printf("cs361>");

		//read line from terminal
		fgets(line, 500, stdin);

		numArgs = parse(line, args, sign, filename);

		//print(args, numArgs);

		performFork(args, sign, filename);

		// free the strings
		freeStrings(line, args, numArgs, sign, filename);
	}
}
//---------------------------------------------------------------------------------